# -*- coding: utf-8 -*-
"""bravo_cleaner.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vLwfOX6DqQ2LcA7P9ZmFyfJ13MNBFUWZ
"""

import pandas as pd
import numpy as np

# Load the data
df = pd.read_csv('/content/bravoscraped.csv')

# Step 1: Handling Missing Data

# Check for missing values
print("Missing values per column:")
print(df.isnull().sum())

# Fill missing values with the mean of the column for numeric columns
numeric_cols = df.select_dtypes(include=[np.number]).columns
df[numeric_cols] = df[numeric_cols].fillna(df[numeric_cols].mean())

# For non-numeric columns, fill with a placeholder (e.g., "Unknown")
non_numeric_cols = df.select_dtypes(exclude=[np.number]).columns
df[non_numeric_cols] = df[non_numeric_cols].fillna("Unknown")

# Step 2: Removing Duplicates

# Find duplicates
duplicates = df[df.duplicated()]
print(f"\nNumber of duplicate rows: {len(duplicates)}")

# Remove duplicates
df.drop_duplicates(inplace=True)

# Step 3: Converting Data Types

# Convert specific columns to appropriate types if applicable
# Example: Convert 'date_posted' and 'date_expires' to datetime
date_cols = ['date_posted', 'date_expires']  # Adjust based on your column names
for col in date_cols:
    df[col] = pd.to_datetime(df[col], errors='coerce')

# Step 4: Handling Outliers

# Define the IQR and outlier bounds for a specific column (e.g., 'minimum_salary')
if 'minimum_salary' in df.columns and 'maximum_salary' in df.columns:
    Q1 = df['minimum_salary'].quantile(0.25)
    Q3 = df['minimum_salary'].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Filter out rows with outliers in the 'minimum_salary' column
    df = df[(df['minimum_salary'] >= lower_bound) & (df['minimum_salary'] <= upper_bound)]

# Step 5: Renaming Columns

# Rename columns to standardize names (adjust based on your needs)
rename_dict = {
    'job_title': 'title',
    'job_city': 'city',
    'job_state': 'state',
    'job_country': 'country',
    # Add more renames as necessary
}

df.rename(columns=rename_dict, inplace=True)

# Step 6: Standardizing Data

# Convert all text in the 'title' column to lowercase
if 'title' in df.columns:
    df['title'] = df['title'].str.lower()

# Strip leading and trailing whitespace from 'title' column
if 'title' in df.columns:
    df['title'] = df['title'].str.strip()

# Step 7: Dealing with Invalid Data

# Remove rows where 'minimum_salary' has invalid data
if 'minimum_salary' in df.columns:
    df_cleaned = df[df['minimum_salary'].apply(lambda x: isinstance(x, (int, float)))]
else:
    df_cleaned = df

# Final cleaned data preview
print("\nCleaned Data:")
print(df_cleaned.head())

# Save cleaned data to a new CSV file
df_cleaned.to_csv('/content/cleaned_bravoscraped.csv', index=False)

import pandas as pd
import numpy as np
import os

# Get the current working directory
current_directory = os.getcwd()
print(f"Current working directory: {current_directory}")

# List files in the current directory
print(f"Files in current directory: {os.listdir(current_directory)}")

# Construct the file path relative to the current working directory
file_path = os.path.join(current_directory, 'bravoscraped.csv')

# Load the data, using the constructed file path or a raw string
try:
    df = pd.read_csv(file_path)  # Use constructed file path
except FileNotFoundError:
    print(f"File not found at: {file_path}")
    print("Attempting to read using raw string path...")
    try:
        df = pd.read_csv(r'/content/bravoscraped.csv') # Or use a raw string
    except FileNotFoundError:
        print(f"File not found at: /content/bravoscraped.csv")
        print("Please ensure the file exists and the path is correct.")
        # Handle the case where the file is not found
        # This could include raising an exception or exiting the script
        # For example:
        # raise FileNotFoundError("The file 'bravoscraped.csv' could not be found.")


import pandas as pd

# Load the data
df = pd.read_csv('/content/bravoscraped.csv')

# Print the column names
print("Column names in the DataFrame:")
print(df.columns.tolist())

import pandas as pd

# Load the data
df = pd.read_csv('/content/bravoscraped.csv')

# Step 1: Handling Missing Data

# Check for missing values
print("Missing values per column:")
print(df.isnull().sum())

# Fill missing values with the mean of the column if applicable
# df.fillna(df.mean(), inplace=True)  # Uncomment if there are numerical columns to fill

# Step 2: Removing Duplicates

# Find duplicates
duplicates = df[df.duplicated()]
print(f"\nNumber of duplicate rows: {len(duplicates)}")

# Remove duplicates
df.drop_duplicates(inplace=True)

# Step 3: Renaming Columns (Update according to your actual column names)
# For example:
# df.rename(columns={'old_name': 'new_name'}, inplace=True)  # Update with actual names

# Step 4: Handling Dates (Update to match your available date columns)
# df['postDate'] = pd.to_datetime(df['postDate'], errors='coerce')  # Example column to convert

# Final cleaned data preview
print("\nCleaned Data Preview:")
print(df.head())

# Optionally, save the cleaned DataFrame to a new CSV
df.to_csv('/content/cleaned_bravoscraped.csv', index=False)